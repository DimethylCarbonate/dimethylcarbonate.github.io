---
layout:             post
title:              C++笔记：指针
subtitle:           间接访问
date:               2024-09-30
author:             Dimethyl
original:           true
header-style:       text
catalog:            true
tags:
    - C++
    - 计算机语言
    - SJTU
    - CS1501 程序设计思想与方法
    - 笔记
---

## 概述

指针就是保存另外一个变量内存地址的变量，使得变量访问更加灵活。

### 定义

定义时应该说清楚三个方面的问题：变量的名称、该变量存储的是一个地址、该地址中存储着什么类型的数据。C++中定义如下：
```C++
类型名 *指针变量名;
int *p;
char *cptr;
```
其中，`*`属于指针变量而不是类型。例如，`int *p1,p2;`便定义了一个整型变量和一个指针变量，而`int *p1,*p2;`则定义了两个指针变量。

指针指向的变量的类型称为指针的**基类型**。

### 操作

#### 赋值：将内存地址保存在指针变量中

指针变量中保存的是一个内存地址，是一个正整数编号。

可用两种方式为指针变量赋值：将本程序的某一变量的地址赋予指针变量或将指针变量的值赋予同类的指针变量。

C++中定义了取地址运算符`&`，它是一个一元运算符，运算对象是一个变量，运算结果是该对象的内存地址。例如，可用`int x,*p=&x;`将变量`x`存入指针变量`p`。

C++在定义指针变量时只负责分配空间，若未赋初值的话该变量便是随机值，因此间接访问未赋初值的指针所指的空间是没有意义的，甚至是很危险的。如果某个指针暂时不用，我们可以把它设置为一个空指针`NULL`（或`nullptr`）表示不指向任何变量。

`NULL`是C++定义的一个符号常量，它的值是整数0。`nullptr`是C++定义的一个表示空指针的指针常量，可以自动转成各种类型的指针，但不能自动转成整型。

间接访问时检测指针是否为空是十分必要的，可以确保指针指向的空间有效。

同类型的指针变量也可以互相赋值。如：
```C++
int x=1,y=2,*p1=&x,*p2=&y;
p2=p1;
```
不同类型的指针之间不能赋值。如果必须在不同类型的指针之间相互赋值，必须使用强制类型转换表示程序员知道该赋值的危险：
```C++
p2=reinterpret_cast<float *>p1;
```

#### 指针变量的访问

C++定义了间接访问运算符（又称解引用运算符）`*`，它是一元运算符，运算对象是一个指针，根据指针的类型返回其指向的变量。

### 统配指针类型`void`

C++中可以将指针声明为`void`，说明这个变量中存放的是一个内存地址但未说明该内存地址中存放的是什么类型的数据。

C++中相同类型的指针方可互相赋值，但是任何类型的指针都可以直接赋值给`void`，因此`void`被称为统配指针类型。

### 指针与常量限定符`const`

常量指针：
```C++
const int *p=&x;
p*=30;//错误，*p是常量不可修改
p=&y;//正确，p是指针可以修改
```
指针常量：
```C++
int *const p=&x;
*p=30;//正确，*p是指针所指地址中的内容可以修改
p=&y;//错误，p是指针常量不可修改
```
指向常量的常量指针：
```C++
const int *const p=&x;
*p=30;//错误，*p是常量不可修改
p=&y;//错误，p是指针常量不可修改
```

## 运算

指针保存的是一个内存地址，其本质是一个整数，指针运算的结果自然也是一个内存地址。因此，对指针进行除法运算是没有意义的。C++规定指针只能进行加减运算。

指针的加减考虑到了指针的基类型。如果一个指向整型的指针`p`的值为1000，那么`++p`的运算结果便是`1004`。

### 指针与数组

对一个指向简单变量的指针进行加减运算是没有意义的。指针的运算是与数组相关的。如果指针`p`指向数列中第$k$个元素，那么`p+i`指向的是第$k+i$个元素。

C++中的数组名保存了数组的起始地址。也就是说数组名是一个值不变的常量指针。

因此，如果定义了整型指针`p`并`p=array`，就可以将该整型指针看作是数组名，对其执行任何数组相关的操作。

因此，下列5行代码都是合法的：
```C++
for(int i=0;i<5;i++){
    cout<<array[i];
}
for(int i=0;i<5;i++){
    cout<<*(array+i);
}
for(p=array;p<array+5;++p){
    cout<<*p;
}
for(p=array,int i=0;i<5;++i){
    cout<<*(p+i);
}
for(p=array,int i=0;i<5;++i){
    cout<<p[i];
}
```

数组与指针最根本的区别在于内存的分配。数组需要分配连续的内存，指针只需要一个存储地址的空间。只有将一个数组名赋予一个指针后，该指针才具备数组名的行为。

## 动态内存分配

### 动态变量

动态变量是指在编写程序时无法确定它们的存在，当程序运行起来随着程序的运行，根据程序的需求动态产生和消亡的变量。

由于动态变量不能在程序中定义，因此动态变量的访问需要通过指向动态变量的指针间接访问。

使用动态变量必须定义一个相应类型的指针，然后通过动态变量申请功能向系统申请一片空间并将该空间的地址存入该指针变量。程序运行结束时，系统会自动回收指针占用的空间，但不会回收动态变量占据的空间，因此动态变量需要程序员在程序中显式释放。

实现动态内存分配，必须提供以下3个功能：定义指针变量、申请和回收动态变量。

#### 创建

动态变量通常存放于一个称为堆的内存区域中，它是使用运算符`new`创建的，该运算符可以创建一个简单变量或数组，格式如下：
```C++
new int;
```
该操作会申请一块能存放相应类型数据的空间，操作的结果是这块空间的首地址。在创建动态变量时也可以指定变量的初值，如：
```C++
int *p;
p=new int;
*p=20;
//OR
int *p=new int(20);
```
C++11中如果指出了变量的初值可以使用`auto`判断所需分配的变量类型，如：
```C++
auto *p=new auto(10);
```
`new`也可以创建一个数组，这个操作申请一块连续的空间，存放指定类型的一组元素，操作的结果是该块空间的首地址。此时，定义的动态变量相当于一个数组名。

动态数组和普通数组的最大区别在于动态数组的规模可以是程序运行过程中某一变量的值或某一表达式计算的结果，而普通数组的长度必须是编译时的常量（尽管某些编译器会帮你解决这个问题）。

同时，也可以为动态数组赋初值，规则和数组赋初值基本相同：
```C++
int *p=new int[5]{1,2,3,4,5};
```
如果给出的初值个数多于数组元素个数，则`new`操作失败。不能申请`auto`类型的动态数组。

动态数组只能通过下标变量访问，不能通过范围`for`访问。

简单的`new`操作并不能实现二维或三维动态数组的创建。

#### 消亡

程序运行时动态变量不会消亡。甚至如果一个函数创建了动态变量，函数返回之后该动态变量依然存在，仍然可以继续使用，因此回收动态变量的空间必须显式地使之消亡。消亡动态变量应该使用`delete`操作，如：
```C++
delete p;    //delete动态变量对应的指针
delete [] p; //消亡一个动态数组
```
如果该动态数组是字符数组，该操作可以不加`[]`。

一旦释放了内存变量，计算机将重新收回这些区域。

#### 内存泄漏

内存泄漏是指申请了一个动态变量，但是之后不需要这个动态变量时没有删除它，或把其对应的指针变量指向另一个变量。这样原有的空间就消失了。计算机认为你在使用它们，但你却不知道它们在哪里。

## 指针与字符串

字符串也可以用指向字符的指针表示。如：
```C++
string="abcde";
char ch[10];string=ch;
string=new char[10];
```
## 指针与函数

### 数组作为函数参数再讨论

数组作为函数参数时传递的实质上是指针。实际上，C++是将数组参数作为指针来处理的。